<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Berry Ultimate Final</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; touch-action: none; }
        #ui { 
            position: fixed; bottom: 25px; left: 50%; transform: translateX(-50%);
            z-index: 100; display: flex; gap: 15px; align-items: center;
            background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(20px);
            padding: 12px 25px; border-radius: 50px; border: 1px solid rgba(255,255,255,0.2);
        }
        .btn {
            width: 45px; height: 45px; border-radius: 50%; border: none;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; background: rgba(255,255,255,0.1); color: #fff; transition: 0.2s;
        }
        .btn svg { width: 24px; height: 24px; fill: currentColor; }
        .btn:active { transform: scale(0.8); }
        .active-mode { background: #9d4edd !important; box-shadow: 0 0 15px #9d4edd; }
        .input-group { display: flex; flex-direction: column; align-items: center; color: rgba(255,255,255,0.5); font-size: 9px; font-weight: bold; }
        input { width: 35px; background: none; border: none; color: white; text-align: center; font-size: 16px; font-weight: bold; outline: none; }
        canvas { display: block; }
    </style>
</head>
<body onclick="initGyro()">

<div id="ui">
    <div class="input-group">
        <input type="number" id="speedInput" value="1" step="0.1">
        <span>СКОР</span>
    </div>

    <div class="input-group">
        <input type="number" id="countInput" value="5">
        <span>ЯГОД</span>
    </div>
    <button class="btn" onclick="spawnMultiple()">
        <svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
    </button>

    <button class="btn" onclick="clearAll()">
        <svg viewBox="0 0 24 24"><path d="M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z"/></svg>
    </button>

    <button id="sparkBtn" class="btn active-mode" onclick="sparksEnabled = !sparksEnabled; this.classList.toggle('active-mode')">
        <svg viewBox="0 0 24 24"><path d="M10,2L12,9L19,11L12,13L10,20L8,13L1,11L8,9L10,2Z"/></svg>
    </button>

    <button id="spaceBtn" class="btn" onclick="toggleSpace()">
        <svg viewBox="0 0 24 24"><path d="M21,16.5C21,16.88 20.79,17.21 20.47,17.38L12.57,21.82C12.41,21.94 12.21,22 12,22C11.79,22 11.59,21.94 11.43,21.82L3.53,17.38C3.21,17.21 3,16.88 3,16.5V7.5C3,7.12 3.21,6.79 3.53,6.62L11.43,2.18C11.59,2.06 11.79,2 12,2C12.21,2 12.41,2.06 12.57,2.18L20.47,6.62C20.79,6.79 21,7.12 21,7.5V16.5Z"/></svg>
    </button>
</div>

<script>
const { Engine, Render, Runner, Bodies, Composite, Mouse, MouseConstraint, Events, Body } = Matter;

const engine = Engine.create();
const world = engine.world;
const render = Render.create({
    element: document.body,
    engine: engine,
    options: { width: window.innerWidth, height: window.innerHeight, wireframes: false, background: 'transparent' }
});

Render.run(render);
Runner.run(Runner.create(), engine);

let walls = [];
function createWalls() {
    if (walls.length) Composite.remove(world, walls);
    const w = window.innerWidth, h = window.innerHeight;
    const opt = { isStatic: true, friction: 0.5, render: { visible: false } };
    walls = [
        Bodies.rectangle(w/2, h+25, w, 50, opt),
        Bodies.rectangle(w/2, -25, w, 50, opt),
        Bodies.rectangle(-25, h/2, 50, h, opt),
        Bodies.rectangle(w+25, h/2, 50, h, opt)
    ];
    Composite.add(world, walls);
}
createWalls();

const TARGET_SIZE = 80;
let isSpaceMode = false, gyroStarted = false, sparksEnabled = true;

// Функция с проверкой ошибок загрузки
function getCircularTexture(imgPath, size, callback) {
    const img = new Image();
    img.src = imgPath;
    img.onload = () => {
        const canvas = document.createElement('canvas');
        canvas.width = size; canvas.height = size;
        const ctx = canvas.getContext('2d');
        ctx.beginPath(); ctx.arc(size/2, size/2, size/2, 0, Math.PI*2); ctx.clip();
        ctx.drawImage(img, 0, 0, size, size);
        callback(canvas.toDataURL());
    };
    img.onerror = () => {
        // Если картинка не найдена - создаем градиентный круг, чтобы не было черного экрана
        const canvas = document.createElement('canvas');
        canvas.width = size; canvas.height = size;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#ff4d4d'; // Красный круг, если картинки нет
        ctx.beginPath(); ctx.arc(size/2, size/2, size/2, 0, Math.PI*2); ctx.fill();
        callback(canvas.toDataURL());
    };
}

function createBerry(x, y) {
    const berryNum = Math.floor(Math.random() * 5) + 1;
    getCircularTexture(`berry${berryNum}.png`, 256, (circularImg) => {
        const berry = Bodies.circle(x, y, TARGET_SIZE/2, {
            restitution: 0.8, friction: 0.1,
            render: { sprite: { texture: circularImg, xScale: TARGET_SIZE/256, yScale: TARGET_SIZE/256 } }
        });
        Composite.add(world, berry);
    });
}

function spawnMultiple() {
    const count = parseInt(document.getElementById('countInput').value) || 5;
    for(let i=0; i<count; i++) createBerry(Math.random()*window.innerWidth, 50);
}

function clearAll() { 
    Composite.allBodies(world).forEach(b => { if(!b.isStatic) Composite.remove(world, b); }); 
}

function toggleSpace() {
    isSpaceMode = !isSpaceMode;
    document.getElementById('spaceBtn').classList.toggle('active-mode');
    
    if(isSpaceMode) {
        world.gravity.scale = 0; // Космос (антигравитация)
        Composite.allBodies(world).forEach(b => {
            if(!b.isStatic) Body.setVelocity(b, { x: (Math.random()-0.5)*5, y: (Math.random()-0.5)*5 });
        });
    } else {
        world.gravity.scale = 0.001; // Обычная гравитация
    }
}

const mouseConstraint = MouseConstraint.create(engine, {
    mouse: Mouse.create(render.canvas), constraint: { stiffness: 0.1, render: { visible: false } }
});
Composite.add(world, mouseConstraint);

let particles = [];
Events.on(engine, 'collisionStart', (event) => {
    if (!sparksEnabled) return;
    event.pairs.forEach(pair => {
        const pos = pair.collision.supports[0];
        if (pos) {
            for(let i=0; i<3; i++) {
                particles.push({ x: pos.x, y: pos.y, vx: (Math.random()-0.5)*6, vy: (Math.random()-0.5)*6, life: 1, size: Math.random()*3+1 });
            }
        }
    });
});

Events.on(engine, 'afterUpdate', () => {
    const speedScale = parseFloat(document.getElementById('speedInput').value) || 1;
    const bodies = Composite.allBodies(world);
    
    bodies.forEach(b => {
        if (!b.isStatic) {
            if (speedScale !== 1) {
                Body.setVelocity(b, { x: b.velocity.x * speedScale, y: b.velocity.y * speedScale });
            }
            if (mouseConstraint.draggedBody === b) {
                Body.setAngularVelocity(b, b.angularVelocity + (Math.random()-0.5)*0.3);
            }
        }
    });

    const ctx = render.context;
    particles = particles.filter(p => {
        p.x += p.vx; p.y += p.vy; p.life -= 0.03;
        ctx.fillStyle = `rgba(157, 78, 221, ${p.life})`;
        ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
        return p.life > 0;
    });
});

function initGyro() {
    if (gyroStarted) return;
    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
        DeviceOrientationEvent.requestPermission().then(res => {
            if (res === 'granted') window.addEventListener('deviceorientation', handleGyro);
        });
    } else {
        window.addEventListener('deviceorientation', handleGyro);
    }
    gyroStarted = true;
}

function handleGyro(e) {
    const s = 0.08;
    if (!isSpaceMode) {
        world.gravity.x = e.gamma * s;
        world.gravity.y = e.beta * s;
    } else {
        Composite.allBodies(world).forEach(b => {
            if(!b.isStatic) Body.applyForce(b, b.position, { x: e.gamma * 0.0005, y: e.beta * 0.0005 });
        });
    }
}

window.addEventListener('resize', () => {
    render.canvas.width = window.innerWidth;
    render.canvas.height = window.innerHeight;
    createWalls();
});

spawnMultiple();
</script>
</body>
</html>
